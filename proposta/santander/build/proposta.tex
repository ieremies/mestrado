% Created 2023-04-30 Sun 12:46
% Intended LaTeX compiler: pdflatex
\documentclass[10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage{todonotes}
\usepackage[brazil, portuges]{babel}
\usepackage{amsthm}
\newtheorem{prep}{Preposição}[section]
\usepackage[a4paper, total={7in, 9in}]{geometry}
\author{Orientador: Rafael C. S. Schouery}
\date{}
\title{Programação Linear Inteira aplicada a problemas de Coloração em Grafos\\\medskip
\large Ieremies Vieira da Fonseca Romero}
\hypersetup{
 pdfauthor={Orientador: Rafael C. S. Schouery},
 pdftitle={Programação Linear Inteira aplicada a problemas de Coloração em Grafos},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 28.2 (Org mode 9.6.1)}, 
 pdflang={Portuges}}
\usepackage[date=year]{biblatex}
\addbibresource{~/arq/bib.bib}
\begin{document}

\maketitle
\begin{abstract}
Uma coloração própria de vértices de um grafo consiste em uma alocação de cores tal que nenhum par de vértices adjacentes possuam a mesma cor.
No problema de coloração de vértices, dado um grafo, procuramos uma coloração própria utilizando o menor número possível de cores.
Além de ser um tradicional problema de teoria dos grafos, o problema se apresenta como NP-difícil e resolvê-lo de forma exata é extremamente relevante na atualidade.
Tais aplicações vão desda alocação de recursos como registradores até o gerenciamento de eventos.

Soluções exatas para este problema utilizam técnicas como enumeração com \emph{Branch-and-Bound} \autocite{Furini2016ImprovedDSATURBased}, programação dinâmica \autocites{Eppstein2006SmallMaximalIndependent}[][]{Byskov2002ChromaticNumberTime} ou programação linear inteira.
Nesse projeto, almejamos aplicar a última e utilizar algoritmos de \emph{Branch-and-Price} para superar os resultados da literatura.
Acreditamos que nosso trabalho se diferencia ao aplicar técnicas recentes para tais algoritmos, o que pode levar a uma melhora do estado-da-arte.
Dessa forma, objetivamos resultados competitivos nas instâncias consolidadas na literatura, bem como possíveis novas formulações, cortes e estratégias para melhor resolvê-las.
\end{abstract}

\section{Introdução}
\label{sec:org73a4276}
Dado um grafo não direcionado, uma \textbf{coloração própria} deste é uma alocação de cores tal que nenhum vértice seja adjacente a outro de mesma cor.
O \textbf{Problema de Coloração de Vértices} (VCP) requer que encontremos uma coloração própria usando o menor número possível de cores.
Decidir se um grafo possui uma coloração própria que usa até \(k \geq 3\) cores é um problema NP-completo \autocite{Garey1979ComputersIntractabilityGuide}, de forma que o problema de otimização também é NP-difícil.

Muitas vezes, deseja-se alocar eventos ou recursos sem que hajam conflitos, seja na divisão de tarefas num cenário de fábricas ou escritórios, ou na organização de eventos.
Assim, desejamos construir uma alocação de eventos a horários sem que, por exemplo, requeira que uma pessoa esteja em dois locais simultaneamente.
Tal problema pode ser convertido a um de coloração transformando cada evento a um vértice no qual dois vértices estão ligados se há necessidade de ao menos uma pessoa estar em ambos eventos.
Assim, numa solução, cada cor irá representar um horário para os eventos acontecerem.

Além dessa, como discutido por \textcite{Malaguti2010SurveyVertexColoring}, diversas são as aplicações do problema, como: agendamento \autocite{Leighton1979GraphColoringAlgorithm}, tabela de horários \autocite{Werra1985introductiontimetabling}, alocação de registradores \autocite{Chow1990prioritybasedcoloring}, comunicação de redes \autocite{Caprara2007PassengerRailwayOptimization} e alocação de banda \autocite{Gamst1986Somelowerbounds}.

As aplicações acima deixam claro que encontrar uma boa (ou até ótima) solução para o problema é crucial.
Cenários reais, muitas vezes, lidam com centenas de milhares de vértices, tornando necessário também resolvermos de forma rápida.

Neste projeto, utilizaremos de Programação Linear Inteira para resolver o problema de forma exata, como discutido na Seção \ref{metodologia}.
É importante mencionar que Programação Dinâmica também é comumente utilizada \autocites{Eppstein2006SmallMaximalIndependent}[][]{Byskov2002ChromaticNumberTime}, mas que vê apenas desenvolvimentos teóricos sem grande aplicabilidade prática no VCP.
Já técnicas de enumeração baseado em \emph{branch-and-bound} \autocite{Brelaz1979Newmethodscolor} possuem resultados práticos melhores que programação dinâmica, mas ainda são superados por técnicas de programação linear inteira.
Por fim, recomendamos as seguintes revisões bibliográficas sobre o problema \autocites{Malaguti2010SurveyVertexColoring}[][]{Lewis2015GuideGraphColouring}[][]{Husfeldt2015Graphcolouringalgorithms}[][]{Lima2018ExactAlgorithmsGraph}.

Neste momento, é importante reforçar algumas notações.
Seja \(G = (V,E)\) um grafo simples não direcionado, denotamos como \(n = |V|\) a quantidade de vértices e \(m = |E|\) a quantidade de arestas.
O número cromático de \(G\),  \(\chi(G)\), é a menor quantidade de cores que pode constituir uma coloração do grafo \(G\).
Por fim, usaremos \(H\) como limitante superior ao número cromático.
Uma cor \(h\) é dita válida para o vértice \(v\) se ela não foi atribuida a nenhum vértice da visinhança aberta de \(v\).

Um conjunto \(S \subseteq V\) é dito independente em \(G\) se, e somente se, não existem arestas em \(E\) que conectem dois elementos de \(S\).
Perceba que o conjunto de vértices coloridos com mesma cor deve ser um conjunto independente.



\section{Metodologia}
\label{sec:org7d3602a}
\label{metodologia}
\textbf{Programação Linear} é uma técnica de otimização a partir da modelagem de \textbf{programas lineares}.
Nestes, definimos uma função objetivo, a qual queremos maximizar ou minimizar com suas variáveis sujeitas a um conjunto de restrições lineares (equações ou inequações lineares) \autocite{Chvatal1983LinearProgramming} . Um programa linear pode ser escrito da seguinte forma:
\begin{alignat*}{4}
& \omit\rlap{minimize \quad \quad $\displaystyle cx$} \\
& \mbox{sujeito a}&& \quad & Ax & \geq b  & \quad &  \\
&                 &&       & x               & \in \mathbb{R}_+ &      &
\end{alignat*}

Para encontrar soluções viáveis com valores ótimos, conhecemos o algoritmo \textbf{simplex} que, apesar de ter complexidade exponencial, no caso médio executa em tempo polinomial \autocite{Borgwardt1986SimplexMethodAlgorithms}.
Além deste, é importante mencionar os métodos de ponto interno \autocite{Karmarkar1984newpolynomialtime} e elipsóide \autocite{Bland1981FeatureArticleTheEllipsoid} como alternativas ao simplex.

Para alguns problemas, como o de coloração de grafos, não faz sentido falar em soluções fracionárias, afinal, não conseguimos designar ``meia cor'' a um vértice.
Para isso, restringimos as variáveis aos inteiros, fazendo assim um \textbf{Programa Linear Inteiro}. Caso apenas um subconjunto das variáveis possuam a restrição de integralidade, chamamos esse programa de linear misto.

O que a princípio pode parecer uma pequena alteração, torna o problema computacionalmente muito mais complexo.
Para encontramos boas soluções viáveis para esse tipo de programa, algoritmos como o simplex não são o suficiente.
Para isso, utilizamos técnicas como \emph{branch-and-bound}, que consiste em dividir o problema em subproblemas menores e, durante o processo, encontrar limitantes que permitam diminuir o espaço de busca.

Por fim, é interessante nesse momento traçar o paralelo com a \textbf{Combinatória Poliédrica}.
Definimos um \textbf{poliedro} como um subconjunto \(P \subseteq \mathbb{R}^n\) tal que ele possa ser descrito por meio de inequações lineares em tal espaço, similar aos programas lineares apresentados acima.
Caso esse poliedro seja limitado, o chamamos de \textbf{politopo}.
Dizemos que um subconjunto do poliedro definido por uma inequação é uma \textbf{face}.
Se esta não for igual ao poliedro inteiro, dizemos ser própria e, caso também não seja vazia, dizemos ser não-trivial.

A seguir, apresentamos as metodologias e técnicas que nos são relevantes para resolver o problema de forma exata.
Em geral, as instâncias usadas para os resultados de experimentos computacionais são as apresentadas em \autocite{GraphColoringInstances}, que foram atualizadas com o passar dos anos.

Proposto por \textcite{Mehrotra1996ColumnGenerationApproach}, uma forma de entender o problema é imaginá-lo como um \textbf{problema de cobertura de conjuntos} (SC) onde os conjuntos disponíveis são os conjuntos independentes dos vértices.

Assim, seja \(S\) a família de conjuntos impendentes do grafo \(G\), a variável binária \(x_s\) representa se o conjunto \(s \in S\) está sendo usado ou não na solução. Nossa formulação então se dá por:
\begin{alignat}{4}
\mathrm{(SC)} \quad & \omit\rlap{minimize  $\displaystyle \sum_{s \in S} x_s$} \nonumber \\
& \mbox{sujeito a}&& \quad & \sum_{s \in S: i \in s} x_{s}&\geq 1 & \quad & i \in V \label{rest9} \\
&                 &&   & x_s       & \in \{0,1\} &    & s \in S \nonumber
\end{alignat}
O primeiro conjunto de restrições garante que todos os vértices de \(V\) estão contidos em algum conjunto independente escolhido.
Apesar de poucas restrições, essa formulação sofre de ter um número exponencial de variáveis, o que a torna impraticável de implementá-la em resolvedores convencionais como \emph{Gurobi}.

Por tal motivo, \textcite{Mehrotra1996ColumnGenerationApproach} propuseram um algoritmo de \emph{branch-and-price} baseado nesta modelagem.
Essa abordagem permite lidar com um número exponencial de variáveis, já que iniciamos com um subconjunto destas e adicionamos com o passar do desenvolvimento da árvore de \emph{branch-and-bound}.

Neste algoritmo, a decisão de qual variável será adicionada é feita pelo subproblema de geração de coluna caracteriza um \textbf{Problema de Conjunto Independente de Peso Máximo}:
\begin{alignat*}{4}
& \omit\rlap{maximize  $\displaystyle \sum_{i \in V} \pi_i z_i$} \\
& \mbox{sujeito a}&& \quad & z_i + z_j &\leq 1 & \quad & (i,j) \in E \\
&                 &&   & z_i       & \in \{0,1\} &    & i \in V
\end{alignat*}
onde \(z_i\) é uma variável binária que indica se o vértice \(i\) está incluso no conjunto independente e \(\pi_i\) é o valor ótimo da variável dual associado à restrição \eqref{rest9}.
Tal problema pode ser resolvido de forma heurística para encontrar a coluna de custo reduzido com valor negativo.
Em caso de soluções fracionárias, os autores sugerem uma estratégia que garante que os subproblemas continuam a ser de coloração de vértices e apenas requer que o grafo original seja alterado.

Além disso, \textcite{Malaguti2011ExactApproachVertex} propõem meta-heurísticas para inicialização e geração de colunas bem como novos esquemas de branching.

Já \textcite{Morrison2014WideBranchingStrategy} apresentam outra forma de realizar a ramificação do processo de \emph{branch-and-bound}.
Tradicionalmente, esta é feita dividindo apenas em dois subproblemas, mas os autores propõem uma abrangente quantidade de subproblemas a cada ramificação com intuito de impedir que cheguemos a subgrafos onde o problema de precificação é mais difícil.
Mais uma vez, resultados computacionais provam que a ideia é competitiva com as anteriores.

Recentemente, \textcite{Morrison2016SolvingPricingProblem} propuseram uma estratégia utilizando diagramas de decisão para agilizar a resolução do problema de precificação que, segundo seus experimentos, possui bons resultados práticos bem como fornece limites inferiores durante o processo.

Por fim,  \textcite{Hoeve2021Graphcoloringdecision} também técnicas de diagrama de decisão.
Nesta, representamos cada atribuição por um arco que liga o ``estado da solução'' antes e depois de tomá-la.
Mais formalmente, para um problema \(P\) definido por um conjunto de variáveis ordenadas \(X = \{x_1,x_2,\dots ,x_n\}\), construímos um diagrama de decisão, um grafo simples acíclico de \(n+1\) níveis.
O primeiro destes, possui apenas um vértice, \(r\), chamado raiz, assim como o último com o vértice \(t\).
O nível \(i\) é um conjunto de nós associados à variável \(x_i\) onde cada um destes possuem arcos para vértices do nível \(i+1\) e tais arcos possuem etiquetas, \(0\) ou \(1\), correspondendo da variável associada.

\textcite{Hoeve2021Graphcoloringdecision} utiliza a formulação de conjuntos independentes para aplicar tal técnica, onde cada variável indica o uso, ou não, de um vértice em um conjunto.
Se conseguíssemos achar um diagrama de decisão que correspondesse exatamente ao problema de coloração, poderíamos resolver o problema por meio de uma formulação de fluxo, na qual cada \(\{r,t\}-\text{caminho}\) seria um conjunto independente e, como demostrado pelos autores, a função objetivo seria nosso número cromático.
Infelizmente, tal diagrama pode conter um número exponencial de nós, o que requer técnicas mais sofisticadas.
Além disso, quando a solução não é exata, a qualidade da solução depende da ordenação das variáveis.

Os autores relatam ter obtido resultados competitivos com outros estados-da-arte utilizando estratégias específicas da literatura de diagrama de decisões para resolver as dificuldades apresentadas acima.
\section{Objetivos}
\label{sec:org75d20d4}
Recentemente, houve avanços significativos na abordagem de branch-and-price para o problema de coloração, resultando em vários trabalhos publicados para outros problemas que utilizam e melhoram essa técnica. Um exemplo notável é o trabalho de \textcite{Lima2022Exactsolutionnetwork}, que apresenta técnicas fortes que melhoram o estado da arte para problemas como o Problema de Empacotamento.

Os autores propõem um modelo baseado em fluxo de arcos para auxiliar em algoritmos de geração de colunas.
Eles também comentam que qualquer problema de cobertura de conjunto consegue ser transformado em um problema de fluxo, o que indica que suas técnicas podem ser relevantes para o nosso problema.
Além disso, eles utilizam \textbf{fixação de variáveis}, técnica na qual é possível provar que algumas variáveis nunca poderão entrar no modelo de \emph{branch-and-pricing} e tornar a solução melhor.
A dificuldade reside em encontrar uma solução dual viável que possibilite computar o custo reduzido, necessário para provar esta afirmação.
Um importante desenvolvimento proposto pelos autores é justamente um modelo linear capaz de encontrar eficientemente uma solução, mesmo que não seja ótima (o que, como argumentado por eles, é ainda mais eficiênte).

Outro bom indicador do que pretendemos fazer é a semelhança de bons resultados recentes como \autocite{Hoeve2021Graphcoloringdecision} que utilizam ideias muito similares.

Técnicas interessantes também foram propostas por \textcite{Pessoa2021SolvingBinPacking} que apresentam um modelo genérico para resolver problema de roteamento.
Quando adiciona-se um corte no \emph{branch-cut-and-price}, isso corresponde a variáveis no dual o que dificulta o subproblema de geração de colunas.
Os autores utilizam cortes de rank-\(1\) com memória limitada para melhorar tal processo.
Além disso, eles usam \textbf{propagação de etiquetas}, técnica comum na resolução de problemas de precificação e que pode ser interessante para o nosso problema.

Nosso principal objetivo é aplicarmos tais novas tecnologias ao problema de coloração.
Além disso, estudaremos a possibilidade de novos cortes e limitantes para as formulações.
Por fim, como apresentado no começo desse projeto, diversos são os problemas similares ou generalizações bem como as aplicações de tais.
Assim, podemos também voltar nossas técnicas e implementações a tais variantes.

\section{Cronograma}
\label{sec:org387a147}
O projeto está dividido em etapas distintas, cada uma com um objetivo específico.
A primeira fase é de revisão bibliográfica, onde serão dedicados \(2\) trimestres para estudar a literatura existente sobre o assunto.
Reforçamos que, apesar deste ser o foco da primeira etapa, a revisão da bibliografia será permanente.
Em seguida, serão dedicados \(2\) trimestres para implementar o estado da arte, onde aplicaremos os conhecimentos adquiridos na fase anterior.
A próxima etapa é o desenvolvimento de novos algoritmos, bem como a implementação e experimentação de tais soluções, onde serão dedicados os trimestres seguintes.
Por último, nos dedicaremos a escrever o relatório final, que apresentará as conclusões e resultados do projeto.

Por fim, o aluno irá, como requerido pela instituição, cursar as três matérias de pós-graduação restantes no primeiro ano, defender seu exame de qualificação de mestrado (EQM) na metade de 2023 e realizar o Programa de Estágio em Docência (PED) no segundo semestre de 2023.

Refletimos o cronograma planejado na Tabela \ref{tab:cron}.

\begin{table}[htbp]
\caption{\label{tab:cron}Cronograma trimestral para este projeto de mestrado, iniciando em Março de 2023.}
\centering
\begin{tabular}{lllllllll}
Atividade & Jun & Set & Dez & Mar & Jun & Set & Dez & Mar\\[0pt]
\hline
Disciplinas & \(\bullet\) & \(\bullet\) &  &  &  &  &  & \\[0pt]
EQM &  & \(\bullet\) &  &  &  &  &  & \\[0pt]
PED &  &  & \(\bullet\) &  &  &  &  & \\[0pt]
Revi. Biblio. & \(\bullet\) & \(\bullet\) & \(\bullet\) &  &  &  &  & \\[0pt]
Implem. estado-da-arte &  &  & \(\bullet\) & \(\bullet\) &  &  &  & \\[0pt]
Desenvolvimento &  &  & \(\bullet\) & \(\bullet\) & \(\bullet\) & \(\bullet\) & \(\bullet\) & \(\bullet\)\\[0pt]
Escrita &  &  &  &  &  &  & \(\bullet\) & \(\bullet\)\\[0pt]
\end{tabular}
\end{table}

\printbibliography
\end{document}